<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>alsaaudio &#8212; alsaaudio documentation 0.8.4 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.8.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="PCM Terminology and Concepts" href="terminology.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-alsaaudio">
<span id="alsaaudio"></span><h1><a class="reference internal" href="#module-alsaaudio" title="alsaaudio (Linux)"><code class="xref py py-mod docutils literal"><span class="pre">alsaaudio</span></code></a><a class="headerlink" href="#module-alsaaudio" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="#module-alsaaudio" title="alsaaudio (Linux)"><code class="xref py py-mod docutils literal"><span class="pre">alsaaudio</span></code></a> module defines functions and classes for using ALSA.</p>
<dl class="function">
<dt id="alsaaudio.pcms">
<code class="descclassname">alsaaudio.</code><code class="descname">pcms</code><span class="sig-paren">(</span><span class="optional">[</span><em>type=PCM_PLAYBACK</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.pcms" title="Permalink to this definition">¶</a></dt>
<dd><p>List available PCM devices by name.</p>
<p>Arguments are:</p>
<ul class="simple">
<li><em>type</em> - can be either <code class="xref py py-const docutils literal"><span class="pre">PCM_CAPTURE</span></code> or <code class="xref py py-const docutils literal"><span class="pre">PCM_PLAYBACK</span></code>
(default).</li>
</ul>
<p><strong>Note:</strong></p>
<p>For <code class="xref py py-const docutils literal"><span class="pre">PCM_PLAYBACK</span></code>, the list of device names should be equivalent
to the list of device names that <code class="docutils literal"><span class="pre">aplay</span> <span class="pre">-L</span></code> displays on the commandline:</p>
<div class="highlight-default"><div class="highlight"><pre>$ aplay -L
</pre></div>
</div>
<p>For <code class="xref py py-const docutils literal"><span class="pre">PCM_CAPTURE</span></code>, the list of device names should be equivalent
to the list of device names that  <code class="docutils literal"><span class="pre">arecord</span> <span class="pre">-L</span></code> displays on the
commandline:</p>
<div class="highlight-default"><div class="highlight"><pre>$ arecord -L
</pre></div>
</div>
<p><em>New in 0.8</em></p>
</dd></dl>

<dl class="function">
<dt id="alsaaudio.cards">
<code class="descclassname">alsaaudio.</code><code class="descname">cards</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.cards" title="Permalink to this definition">¶</a></dt>
<dd><p>List the available ALSA cards by name. This function is only moderately
useful. If you want to see a list of available PCM devices, use <a class="reference internal" href="#alsaaudio.pcms" title="alsaaudio.pcms"><code class="xref py py-func docutils literal"><span class="pre">pcms()</span></code></a>
instead.</p>
</dd></dl>

<dl class="function">
<dt id="alsaaudio.mixers">
<code class="descclassname">alsaaudio.</code><code class="descname">mixers</code><span class="sig-paren">(</span><em>cardindex=-1</em>, <em>device='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.mixers" title="Permalink to this definition">¶</a></dt>
<dd><p>List the available mixers. The arguments are:</p>
<ul class="simple">
<li><em>cardindex</em> - the card index. If this argument is given, the device name
is constructed as: &#8216;hw:<em>cardindex</em>&#8216; and
the <cite>device</cite> keyword argument is ignored. <code class="docutils literal"><span class="pre">0</span></code> is the first hardware sound
card.</li>
<li><em>device</em> - the name of the device on which the mixer resides. The default
is <code class="docutils literal"><span class="pre">'default'</span></code>.</li>
</ul>
<p><strong>Note:</strong> For a list of available controls, you can also use <code class="docutils literal"><span class="pre">amixer</span></code> on
the commandline:</p>
<div class="highlight-default"><div class="highlight"><pre>$ amixer
</pre></div>
</div>
<p>To elaborate the example, calling <a class="reference internal" href="#alsaaudio.mixers" title="alsaaudio.mixers"><code class="xref py py-func docutils literal"><span class="pre">mixers()</span></code></a> with the argument
<code class="docutils literal"><span class="pre">cardindex=0</span></code> should give the same list of Mixer controls as:</p>
<div class="highlight-default"><div class="highlight"><pre>$ amixer -c 0
</pre></div>
</div>
<p>And calling <a class="reference internal" href="#alsaaudio.mixers" title="alsaaudio.mixers"><code class="xref py py-func docutils literal"><span class="pre">mixers()</span></code></a> with the argument <code class="docutils literal"><span class="pre">device='foo'</span></code> should give
the same list of Mixer controls as:</p>
<div class="highlight-default"><div class="highlight"><pre>$ amixer -D foo
</pre></div>
</div>
<p><em>Changed in 0.8</em>:</p>
<ul class="simple">
<li>The keyword argument <cite>device</cite> is new and can be used to
select virtual devices. As a result, the default behaviour has subtly
changed. Since 0.8, this functions returns the mixers for the default
device, not the mixers for the first card.</li>
</ul>
</dd></dl>

<div class="section" id="pcm-objects">
<span id="id1"></span><h2>PCM Objects<a class="headerlink" href="#pcm-objects" title="Permalink to this headline">¶</a></h2>
<p>PCM objects in <a class="reference internal" href="#module-alsaaudio" title="alsaaudio (Linux)"><code class="xref py py-mod docutils literal"><span class="pre">alsaaudio</span></code></a> can play or capture (record) PCM
sound through speakers or a microphone. The PCM constructor takes the
following arguments:</p>
<dl class="class">
<dt id="alsaaudio.PCM">
<em class="property">class </em><code class="descclassname">alsaaudio.</code><code class="descname">PCM</code><span class="sig-paren">(</span><em>type=PCM_PLAYBACK</em>, <em>mode=PCM_NORMAL</em>, <em>device='default'</em>, <em>cardindex=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.PCM" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a PCM device (either for playback and
recording). The arguments are:</p>
<ul class="simple">
<li><em>type</em> - can be either <code class="xref py py-const docutils literal"><span class="pre">PCM_CAPTURE</span></code> or <code class="xref py py-const docutils literal"><span class="pre">PCM_PLAYBACK</span></code>
(default).</li>
<li><em>mode</em> - can be either <code class="xref py py-const docutils literal"><span class="pre">PCM_NONBLOCK</span></code>, or <code class="xref py py-const docutils literal"><span class="pre">PCM_NORMAL</span></code>
(default).</li>
<li><em>device</em> - the name of the PCM device that should be used (for example
a value from the output of <a class="reference internal" href="#alsaaudio.pcms" title="alsaaudio.pcms"><code class="xref py py-func docutils literal"><span class="pre">pcms()</span></code></a>). The default value is
<code class="docutils literal"><span class="pre">'default'</span></code>.</li>
<li><em>cardindex</em> - the card index. If this argument is given, the device name
is constructed as &#8216;hw:<em>cardindex</em>&#8216; and
the <cite>device</cite> keyword argument is ignored.
<code class="docutils literal"><span class="pre">0</span></code> is the first hardware sound card.</li>
</ul>
<p>This will construct a PCM object with these default settings:</p>
<ul class="simple">
<li>Sample format: <code class="xref py py-const docutils literal"><span class="pre">PCM_FORMAT_S16_LE</span></code></li>
<li>Rate: 44100 Hz</li>
<li>Channels: 2</li>
<li>Period size: 32 frames</li>
</ul>
<p><em>Changed in 0.8:</em></p>
<ul class="simple">
<li>The <cite>card</cite> keyword argument is still supported,
but deprecated. Please use <cite>device</cite> instead.</li>
<li>The keyword argument <cite>cardindex</cite> was added.</li>
</ul>
<p>The <cite>card</cite> keyword is deprecated because it guesses the real ALSA
name of the card. This was always fragile and broke some legitimate usecases.</p>
</dd></dl>

<p>PCM objects have the following methods:</p>
<dl class="method">
<dt id="alsaaudio.PCM.pcmtype">
<code class="descclassname">PCM.</code><code class="descname">pcmtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.PCM.pcmtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of PCM object. Either <code class="xref py py-const docutils literal"><span class="pre">PCM_CAPTURE</span></code> or
<code class="xref py py-const docutils literal"><span class="pre">PCM_PLAYBACK</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.PCM.pcmmode">
<code class="descclassname">PCM.</code><code class="descname">pcmmode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.PCM.pcmmode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mode of the PCM object. One of <code class="xref py py-const docutils literal"><span class="pre">PCM_NONBLOCK</span></code>,
<code class="xref py py-const docutils literal"><span class="pre">PCM_ASYNC</span></code>, or <code class="xref py py-const docutils literal"><span class="pre">PCM_NORMAL</span></code></p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.PCM.cardname">
<code class="descclassname">PCM.</code><code class="descname">cardname</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.PCM.cardname" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the sound card used by this PCM object.</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.PCM.setchannels">
<code class="descclassname">PCM.</code><code class="descname">setchannels</code><span class="sig-paren">(</span><em>nchannels</em><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.PCM.setchannels" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to set the number of capture or playback channels. Common
values are: <code class="docutils literal"><span class="pre">1</span></code> = mono, <code class="docutils literal"><span class="pre">2</span></code> = stereo, and <code class="docutils literal"><span class="pre">6</span></code> = full 6 channel audio.
Few sound cards support more than 2 channels</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.PCM.setrate">
<code class="descclassname">PCM.</code><code class="descname">setrate</code><span class="sig-paren">(</span><em>rate</em><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.PCM.setrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the sample rate in Hz for the device. Typical values are <code class="docutils literal"><span class="pre">8000</span></code>
(mainly used for telephony), <code class="docutils literal"><span class="pre">16000</span></code>, <code class="docutils literal"><span class="pre">44100</span></code> (CD quality),
<code class="docutils literal"><span class="pre">48000</span></code> and <code class="docutils literal"><span class="pre">96000</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.PCM.setformat">
<code class="descclassname">PCM.</code><code class="descname">setformat</code><span class="sig-paren">(</span><em>format</em><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.PCM.setformat" title="Permalink to this definition">¶</a></dt>
<dd><p>The sound <em>format</em> of the device. Sound format controls how the PCM device
interpret data for playback, and how data is encoded in captures.</p>
<p>The following formats are provided by ALSA:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_S8</span></code></td>
<td>Signed 8 bit samples for each channel</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_U8</span></code></td>
<td>Signed 8 bit samples for each channel</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_S16_LE</span></code></td>
<td>Signed 16 bit samples for each channel Little Endian byte order)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_S16_BE</span></code></td>
<td>Signed 16 bit samples for each channel (Big Endian byte order)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_U16_LE</span></code></td>
<td>Unsigned 16 bit samples for each channel (Little Endian byte order)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_U16_BE</span></code></td>
<td>Unsigned 16 bit samples for each channel (Big Endian byte order)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_S24_LE</span></code></td>
<td>Signed 24 bit samples for each channel (Little Endian byte order)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_S24_BE</span></code></td>
<td>Signed 24 bit samples for each channel (Big Endian byte order)}</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_U24_LE</span></code></td>
<td>Unsigned 24 bit samples for each channel (Little Endian byte order)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_U24_BE</span></code></td>
<td>Unsigned 24 bit samples for each channel (Big Endian byte order)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_S32_LE</span></code></td>
<td>Signed 32 bit samples for each channel (Little Endian byte order)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_S32_BE</span></code></td>
<td>Signed 32 bit samples for each channel (Big Endian byte order)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_U32_LE</span></code></td>
<td>Unsigned 32 bit samples for each channel (Little Endian byte order)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_U32_BE</span></code></td>
<td>Unsigned 32 bit samples for each channel (Big Endian byte order)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_FLOAT_LE</span></code></td>
<td>32 bit samples encoded as float (Little Endian byte order)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_FLOAT_BE</span></code></td>
<td>32 bit samples encoded as float (Big Endian byte order)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_FLOAT64_LE</span></code></td>
<td>64 bit samples encoded as float (Little Endian byte order)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_FLOAT64_BE</span></code></td>
<td>64 bit samples encoded as float (Big Endian byte order)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_MU_LAW</span></code></td>
<td>A logarithmic encoding (used by Sun .au files and telephony)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_A_LAW</span></code></td>
<td>Another logarithmic encoding</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_IMA_ADPCM</span></code></td>
<td>A 4:1 compressed format defined by the Interactive Multimedia Association.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_MPEG</span></code></td>
<td>MPEG encoded audio?</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">PCM_FORMAT_GSM</span></code></td>
<td>9600 bits/s constant rate encoding for speech</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.PCM.setperiodsize">
<code class="descclassname">PCM.</code><code class="descname">setperiodsize</code><span class="sig-paren">(</span><em>period</em><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.PCM.setperiodsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the actual period size in frames. Each write should consist of
exactly this number of frames, and each read will return this
number of frames (unless the device is in <code class="xref py py-const docutils literal"><span class="pre">PCM_NONBLOCK</span></code> mode, in
which case it may return nothing at all)</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.PCM.read">
<code class="descclassname">PCM.</code><code class="descname">read</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.PCM.read" title="Permalink to this definition">¶</a></dt>
<dd><p>In <code class="xref py py-const docutils literal"><span class="pre">PCM_NORMAL</span></code> mode, this function blocks until a full period is
available, and then returns a tuple (length,data) where <em>length</em> is
the number of frames of captured data, and <em>data</em> is the captured
sound frames as a string. The length of the returned data will be
periodsize*framesize bytes.</p>
<p>In <code class="xref py py-const docutils literal"><span class="pre">PCM_NONBLOCK</span></code> mode, the call will not block, but will return
<code class="docutils literal"><span class="pre">(0,'')</span></code> if no new period has become available since the last
call to read.</p>
<p>In case of an overrun, this function will return a negative size: <code class="xref py py-const docutils literal"><span class="pre">-EPIPE</span></code>.
This indicates that data was lost, even if the operation itself succeeded.
Try using a larger periodsize.</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.PCM.write">
<code class="descclassname">PCM.</code><code class="descname">write</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.PCM.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes (plays) the sound in data. The length of data <em>must</em> be a
multiple of the frame size, and <em>should</em> be exactly the size of a
period. If less than &#8216;period size&#8217; frames are provided, the actual
playout will not happen until more data is written.</p>
<p>If the device is not in <code class="xref py py-const docutils literal"><span class="pre">PCM_NONBLOCK</span></code> mode, this call will block if
the kernel buffer is full, and until enough sound has been played
to allow the sound data to be buffered. The call always returns the
size of the data provided.</p>
<p>In <code class="xref py py-const docutils literal"><span class="pre">PCM_NONBLOCK</span></code> mode, the call will return immediately, with a
return value of zero, if the buffer is full. In this case, the data
should be written at a later time.</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.PCM.pause">
<code class="descclassname">PCM.</code><code class="descname">pause</code><span class="sig-paren">(</span><span class="optional">[</span><em>enable=True</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.PCM.pause" title="Permalink to this definition">¶</a></dt>
<dd><p>If <em>enable</em> is <code class="xref py py-const docutils literal"><span class="pre">True</span></code>, playback or capture is paused.
Otherwise, playback/capture is resumed.</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.PCM.polldescriptors">
<code class="descclassname">PCM.</code><code class="descname">polldescriptors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.PCM.polldescriptors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of <em>(file descriptor, eventmask)</em> that can be used to
wait for changes on the mixer with <em>select.poll</em>.</p>
<p>The <em>eventmask</em> value is compatible with <a class="reference external" href="http://docs.python.org/library/select.html#poll-objects">poll.register</a> in the Python
<code class="xref py py-const docutils literal"><span class="pre">select</span></code> module.</p>
</dd></dl>

<p><strong>A few hints on using PCM devices for playback</strong></p>
<p>The most common reason for problems with playback of PCM audio is that writes
to PCM devices must <em>exactly</em> match the data rate of the device.</p>
<p>If too little data is written to the device, it will underrun, and
ugly clicking sounds will occur. Conversely, of too much data is
written to the device, the write function will either block
(<code class="xref py py-const docutils literal"><span class="pre">PCM_NORMAL</span></code> mode) or return zero (<code class="xref py py-const docutils literal"><span class="pre">PCM_NONBLOCK</span></code> mode).</p>
<p>If your program does nothing but play sound, the best strategy is to put the
device in <code class="xref py py-const docutils literal"><span class="pre">PCM_NORMAL</span></code> mode, and just write as much data to the device as
possible. This strategy can also be achieved by using a separate
thread with the sole task of playing out sound.</p>
<p>In GUI programs, however, it may be a better strategy to setup the device,
preload the buffer with a few periods by calling write a couple of times, and
then use some timer method to write one period size of data to the device every
period. The purpose of the preloading is to avoid underrun clicks if the used
timer doesn&#8217;t expire exactly on time.</p>
<p>Also note, that most timer APIs that you can find for Python will
accummulate time delays: If you set the timer to expire after 1/10&#8217;th
of a second, the actual timeout will happen slightly later, which will
accumulate to quite a lot after a few seconds. Hint: use time.time()
to check how much time has really passed, and add extra writes as nessecary.</p>
</div>
<div class="section" id="mixer-objects">
<span id="id3"></span><h2>Mixer Objects<a class="headerlink" href="#mixer-objects" title="Permalink to this headline">¶</a></h2>
<p>Mixer objects provides access to the ALSA mixer API.</p>
<dl class="class">
<dt id="alsaaudio.Mixer">
<em class="property">class </em><code class="descclassname">alsaaudio.</code><code class="descname">Mixer</code><span class="sig-paren">(</span><em>control='Master'</em>, <em>id=0</em>, <em>cardindex=-1</em>, <em>device='default'</em><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments are:</p>
<ul class="simple">
<li><em>control</em> - specifies which control to manipulate using this mixer
object. The list of available controls can be found with the
<a class="reference internal" href="#module-alsaaudio" title="alsaaudio (Linux)"><code class="xref py py-mod docutils literal"><span class="pre">alsaaudio</span></code></a>.<a class="reference internal" href="#alsaaudio.mixers" title="alsaaudio.mixers"><code class="xref py py-func docutils literal"><span class="pre">mixers()</span></code></a> function.  The default value is
<code class="docutils literal"><span class="pre">'Master'</span></code> - other common controls may be <code class="docutils literal"><span class="pre">'Master</span> <span class="pre">Mono'</span></code>, <code class="docutils literal"><span class="pre">'PCM'</span></code>,
<code class="docutils literal"><span class="pre">'Line'</span></code>, etc.</li>
<li><em>id</em> - the id of the mixer control. Default is <code class="docutils literal"><span class="pre">0</span></code>.</li>
<li><em>cardindex</em> - specifies which card should be used. If this argument
is given, the device name is constructed like this: &#8216;hw:<em>cardindex</em>&#8216; and
the <cite>device</cite> keyword argument is ignored. <code class="docutils literal"><span class="pre">0</span></code> is the
first sound card.</li>
<li><em>device</em> - the name of the device on which the mixer resides. The default
value is <code class="docutils literal"><span class="pre">'default'</span></code>.</li>
</ul>
<p><em>Changed in 0.8</em>:</p>
<ul class="simple">
<li>The keyword argument <cite>device</cite> is new and can be used to select virtual
devices.</li>
</ul>
</dd></dl>

<p>Mixer objects have the following methods:</p>
<dl class="method">
<dt id="alsaaudio.Mixer.cardname">
<code class="descclassname">Mixer.</code><code class="descname">cardname</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer.cardname" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the sound card used by this Mixer object</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.Mixer.mixer">
<code class="descclassname">Mixer.</code><code class="descname">mixer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer.mixer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the specific mixer controlled by this object, For example
<code class="docutils literal"><span class="pre">'Master'</span></code> or <code class="docutils literal"><span class="pre">'PCM'</span></code></p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.Mixer.mixerid">
<code class="descclassname">Mixer.</code><code class="descname">mixerid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer.mixerid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ID of the ALSA mixer controlled by this object.</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.Mixer.switchcap">
<code class="descclassname">Mixer.</code><code class="descname">switchcap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer.switchcap" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the switches which are defined by this specific mixer.
Possible values in this list are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Switch</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8216;Mute&#8217;</td>
<td>This mixer can mute</td>
</tr>
<tr class="row-odd"><td>&#8216;Joined Mute&#8217;</td>
<td>This mixer can mute all channels at the same time</td>
</tr>
<tr class="row-even"><td>&#8216;Playback Mute&#8217;</td>
<td>This mixer can mute the playback output</td>
</tr>
<tr class="row-odd"><td>&#8216;Joined Playback Mute&#8217;</td>
<td>Mute playback for all channels at the same time}</td>
</tr>
<tr class="row-even"><td>&#8216;Capture Mute&#8217;</td>
<td>Mute sound capture</td>
</tr>
<tr class="row-odd"><td>&#8216;Joined Capture Mute&#8217;</td>
<td>Mute sound capture for all channels at a time}</td>
</tr>
<tr class="row-even"><td>&#8216;Capture Exclusive&#8217;</td>
<td>Not quite sure what this is</td>
</tr>
</tbody>
</table>
<p>To manipulate these switches use the <a class="reference internal" href="#alsaaudio.Mixer.setrec" title="alsaaudio.Mixer.setrec"><code class="xref py py-meth docutils literal"><span class="pre">setrec()</span></code></a> or
<a class="reference internal" href="#alsaaudio.Mixer.setmute" title="alsaaudio.Mixer.setmute"><code class="xref py py-meth docutils literal"><span class="pre">setmute()</span></code></a> methods</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.Mixer.volumecap">
<code class="descclassname">Mixer.</code><code class="descname">volumecap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer.volumecap" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the volume control capabilities of this
mixer. Possible values in the list are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Capability</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8216;Volume&#8217;</td>
<td>This mixer can control volume</td>
</tr>
<tr class="row-odd"><td>&#8216;Joined Volume&#8217;</td>
<td>This mixer can control volume for all channels at the same time</td>
</tr>
<tr class="row-even"><td>&#8216;Playback Volume&#8217;</td>
<td>This mixer can manipulate the playback output</td>
</tr>
<tr class="row-odd"><td>&#8216;Joined Playback Volume&#8217;</td>
<td>Manipulate playback volumne for all channels at the same time</td>
</tr>
<tr class="row-even"><td>&#8216;Capture Volume&#8217;</td>
<td>Manipulate sound capture volume</td>
</tr>
<tr class="row-odd"><td>&#8216;Joined Capture Volume&#8217;</td>
<td>Manipulate sound capture volume for all channels at a time</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.Mixer.getenum">
<code class="descclassname">Mixer.</code><code class="descname">getenum</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer.getenum" title="Permalink to this definition">¶</a></dt>
<dd><p>For enumerated controls, return the currently selected item and  the list of
items available.</p>
<p>Returns a tuple <em>(string, list of strings)</em>.</p>
<p>For example, my soundcard has a Mixer called <em>Mono Output Select</em>. Using
<em>amixer</em>, I get:</p>
<div class="highlight-default"><div class="highlight"><pre>$ amixer get &quot;Mono Output Select&quot;
Simple mixer control &#39;Mono Output Select&#39;,0
  Capabilities: enum
  Items: &#39;Mix&#39; &#39;Mic&#39;
  Item0: &#39;Mix&#39;
</pre></div>
</div>
<p>Using <a class="reference internal" href="#module-alsaaudio" title="alsaaudio (Linux)"><code class="xref py py-mod docutils literal"><span class="pre">alsaaudio</span></code></a>, one could do:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">alsaaudio</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">alsaaudio</span><span class="o">.</span><span class="n">Mixer</span><span class="p">(</span><span class="s">&#39;Mono Output Select&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">getenum</span><span class="p">()</span>
<span class="go">(&#39;Mix&#39;, [&#39;Mix&#39;, &#39;Mic&#39;])</span>
</pre></div>
</div>
<p>This method will return an empty tuple if the mixer is not an  enumerated
control.</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.Mixer.getmute">
<code class="descclassname">Mixer.</code><code class="descname">getmute</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer.getmute" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list indicating the current mute setting for each
channel. 0 means not muted, 1 means muted.</p>
<p>This method will fail if the mixer has no playback switch capabilities.</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.Mixer.getrange">
<code class="descclassname">Mixer.</code><code class="descname">getrange</code><span class="sig-paren">(</span><span class="optional">[</span><em>direction</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer.getrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the volume range of the ALSA mixer controlled by this object.</p>
<p>The optional <em>direction</em> argument can be either <code class="xref py py-const docutils literal"><span class="pre">PCM_PLAYBACK</span></code> or
<code class="xref py py-const docutils literal"><span class="pre">PCM_CAPTURE</span></code>, which is relevant if the mixer can control both
playback and capture volume.  The default value is <code class="xref py py-const docutils literal"><span class="pre">PCM_PLAYBACK</span></code>
if the mixer has playback channels, otherwise it is <code class="xref py py-const docutils literal"><span class="pre">PCM_CAPTURE</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.Mixer.getrec">
<code class="descclassname">Mixer.</code><code class="descname">getrec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer.getrec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list indicating the current record mute setting for each channel. 0
means not recording, 1 means recording.</p>
<p>This method will fail if the mixer has no capture switch capabilities.</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.Mixer.getvolume">
<code class="descclassname">Mixer.</code><code class="descname">getvolume</code><span class="sig-paren">(</span><span class="optional">[</span><em>direction</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer.getvolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list with the current volume settings for each channel. The list
elements are integer percentages.</p>
<p>The optional <em>direction</em> argument can be either <code class="xref py py-const docutils literal"><span class="pre">PCM_PLAYBACK</span></code> or
<code class="xref py py-const docutils literal"><span class="pre">PCM_CAPTURE</span></code>, which is relevant if the mixer can control both
playback and capture volume. The default value is <code class="xref py py-const docutils literal"><span class="pre">PCM_PLAYBACK</span></code>
if the mixer has playback channels, otherwise it is <code class="xref py py-const docutils literal"><span class="pre">PCM_CAPTURE</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.Mixer.setvolume">
<code class="descclassname">Mixer.</code><code class="descname">setvolume</code><span class="sig-paren">(</span><em>volume</em><span class="optional">[</span>, <em>channel</em><span class="optional">]</span><span class="optional">[</span>, <em>direction</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer.setvolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the current volume settings for this mixer. The <em>volume</em> argument
controls the new volume setting as an integer percentage.</p>
<p>If the optional argument <em>channel</em> is present, the volume is set
only for this channel. This assumes that the mixer can control the
volume for the channels independently.</p>
<p>The optional <em>direction</em> argument can be either <code class="xref py py-const docutils literal"><span class="pre">PCM_PLAYBACK</span></code> or
<code class="xref py py-const docutils literal"><span class="pre">PCM_CAPTURE</span></code>, which is relevant if the mixer can control both
playback and capture volume. The default value is <code class="xref py py-const docutils literal"><span class="pre">PCM_PLAYBACK</span></code>
if the mixer has playback channels, otherwise it is <code class="xref py py-const docutils literal"><span class="pre">PCM_CAPTURE</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.Mixer.setmute">
<code class="descclassname">Mixer.</code><code class="descname">setmute</code><span class="sig-paren">(</span><em>mute</em><span class="optional">[</span>, <em>channel</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer.setmute" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the mute flag to a new value. The <em>mute</em> argument is either 0 for not
muted, or 1 for muted.</p>
<p>The optional <em>channel</em> argument controls which channel is
muted. The default is to set the mute flag for all channels.</p>
<p>This method will fail if the mixer has no playback mute capabilities</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.Mixer.setrec">
<code class="descclassname">Mixer.</code><code class="descname">setrec</code><span class="sig-paren">(</span><em>capture</em><span class="optional">[</span>, <em>channel</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer.setrec" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the capture mute flag to a new value. The <em>capture</em> argument
is either 0 for no capture, or 1 for capture.</p>
<p>The optional <em>channel</em> argument controls which channel is
changed. The default is to set the capture flag for all channels.</p>
<p>This method will fail if the mixer has no capture switch capabilities.</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.Mixer.polldescriptors">
<code class="descclassname">Mixer.</code><code class="descname">polldescriptors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer.polldescriptors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of <em>(file descriptor, eventmask)</em> that can be used to
wait for changes on the mixer with <em>select.poll</em>.</p>
<p>The <em>eventmask</em> value is compatible with <a class="reference external" href="http://docs.python.org/library/select.html#poll-objects">poll.register</a> in the Python
<code class="xref py py-const docutils literal"><span class="pre">select</span></code> module.</p>
</dd></dl>

<dl class="method">
<dt id="alsaaudio.Mixer.handleevents">
<code class="descclassname">Mixer.</code><code class="descname">handleevents</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#alsaaudio.Mixer.handleevents" title="Permalink to this definition">¶</a></dt>
<dd><p>Acknowledge events on the <em>polldescriptors</em> file descriptors
to prevent subsequent polls from returning the same events again.
Returns the number of events that were acknowledged.</p>
</dd></dl>

<p><strong>A rant on the ALSA Mixer API</strong></p>
<p>The ALSA mixer API is extremely complicated - and hardly documented at all.
<a class="reference internal" href="#module-alsaaudio" title="alsaaudio (Linux)"><code class="xref py py-mod docutils literal"><span class="pre">alsaaudio</span></code></a> implements a much simplified way to access this API. In
designing the API I&#8217;ve had to make some choices which may limit what can and
cannot be controlled through the API. However, if I had chosen to implement the
full API, I would have reexposed the horrible complexity/documentation ratio of
the underlying API.  At least the <a class="reference internal" href="#module-alsaaudio" title="alsaaudio (Linux)"><code class="xref py py-mod docutils literal"><span class="pre">alsaaudio</span></code></a> API is easy to
understand and use.</p>
<p>If my design choises prevents you from doing something that the underlying API
would have allowed, please let me know, so I can incorporate these needs into
future versions.</p>
<p>If the current state of affairs annoys you, the best you can do is to write a
HOWTO on the API and make this available on the net. Until somebody does this,
the availability of ALSA mixer capable devices will stay quite limited.</p>
<p>Unfortunately, I&#8217;m not able to create such a HOWTO myself, since I only
understand half of the API, and that which I do understand has come from a
painful trial and error process.</p>
</div>
<div class="section" id="examples">
<span id="pcm-example"></span><h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>The following example are provided:</p>
<ul class="simple">
<li><cite>playwav.py</cite></li>
<li><cite>recordtest.py</cite></li>
<li><cite>playbacktest.py</cite></li>
<li><cite>mixertest.py</cite></li>
</ul>
<p>All examples (except <cite>mixertest.py</cite>) accept the commandline option
<em>-c &lt;cardname&gt;</em>.</p>
<p>To determine a valid card name, use the commandline ALSA player:</p>
<div class="highlight-default"><div class="highlight"><pre>$ aplay -L
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default"><div class="highlight"><pre>$ python

&gt;&gt;&gt; import alsaaudio
&gt;&gt;&gt; alsaaudio.pcms()
</pre></div>
</div>
<p>mixertest.py accepts the commandline options <em>-d &lt;device&gt;</em> and
<em>-c &lt;cardindex&gt;</em>.</p>
<div class="section" id="playwav-py">
<h3>playwav.py<a class="headerlink" href="#playwav-py" title="Permalink to this headline">¶</a></h3>
<p><strong>playwav.py</strong> plays a wav file.</p>
<p>To test PCM playback (on your default soundcard), run:</p>
<div class="highlight-default"><div class="highlight"><pre>$ python playwav.py &lt;wav file&gt;
</pre></div>
</div>
</div>
<div class="section" id="recordtest-py-and-playbacktest-py">
<h3>recordtest.py and playbacktest.py<a class="headerlink" href="#recordtest-py-and-playbacktest-py" title="Permalink to this headline">¶</a></h3>
<p><strong>recordtest.py</strong> and <strong>playbacktest.py</strong> will record and play a raw
sound file in CD quality.</p>
<p>To test PCM recordings (on your default soundcard), run:</p>
<div class="highlight-default"><div class="highlight"><pre>$ python recordtest.py &lt;filename&gt;
</pre></div>
</div>
<p>Speak into the microphone, and interrupt the recording at any time
with <code class="docutils literal"><span class="pre">Ctl-C</span></code>.</p>
<p>Play back the recording with:</p>
<div class="highlight-default"><div class="highlight"><pre>$ python playbacktest.py &lt;filename&gt;
</pre></div>
</div>
</div>
<div class="section" id="mixertest-py">
<h3>mixertest.py<a class="headerlink" href="#mixertest-py" title="Permalink to this headline">¶</a></h3>
<p>Without arguments, <strong>mixertest.py</strong> will list all available <em>controls</em> on the
default soundcard.</p>
<p>The output might look like this:</p>
<div class="highlight-default"><div class="highlight"><pre>$ ./mixertest.py
Available mixer controls:
   &#39;Master&#39;
   &#39;Master Mono&#39;
   &#39;Headphone&#39;
   &#39;PCM&#39;
   &#39;Line&#39;
   &#39;Line In-&gt;Rear Out&#39;
   &#39;CD&#39;
   &#39;Mic&#39;
   &#39;PC Speaker&#39;
   &#39;Aux&#39;
   &#39;Mono Output Select&#39;
   &#39;Capture&#39;
   &#39;Mix&#39;
   &#39;Mix Mono&#39;
</pre></div>
</div>
<p>With a single argument - the <em>control</em>, it will display the settings of
that control; for example:</p>
<div class="highlight-default"><div class="highlight"><pre>$ ./mixertest.py Master
Mixer name: &#39;Master&#39;
Capabilities: Playback Volume Playback Mute
Channel 0 volume: 61%
Channel 1 volume: 61%
</pre></div>
</div>
<p>With two arguments, the <em>control</em> and a <em>parameter</em>, it will set the
parameter on the mixer:</p>
<div class="highlight-default"><div class="highlight"><pre>$ ./mixertest.py Master mute
</pre></div>
</div>
<p>This will mute the Master mixer.</p>
<p>Or:</p>
<div class="highlight-default"><div class="highlight"><pre>$ ./mixertest.py Master 40
</pre></div>
</div>
<p>This sets the volume to 40% on all channels.</p>
<p>To select a different soundcard, use either the <em>device</em> or <em>cardindex</em>
argument:</p>
<div class="highlight-default"><div class="highlight"><pre>$ ./mixertest.py -c 0 Master
Mixer name: &#39;Master&#39;
Capabilities: Playback Volume Playback Mute
Channel 0 volume: 61%
Channel 1 volume: 61%
</pre></div>
</div>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>ALSA also allows <code class="docutils literal"><span class="pre">PCM_ASYNC</span></code>, but this is not supported yet.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">alsaaudio</span></code></a><ul>
<li><a class="reference internal" href="#pcm-objects">PCM Objects</a></li>
<li><a class="reference internal" href="#mixer-objects">Mixer Objects</a></li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#playwav-py">playwav.py</a></li>
<li><a class="reference internal" href="#recordtest-py-and-playbacktest-py">recordtest.py and playbacktest.py</a></li>
<li><a class="reference internal" href="#mixertest-py">mixertest.py</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="terminology.html" title="previous chapter">PCM Terminology and Concepts</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/libalsaaudio.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Lars Immisch & Casper Wilstrup.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/libalsaaudio.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>